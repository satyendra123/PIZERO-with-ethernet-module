raspberry pi with touch screen run the tkinter gui directly

1) sudo apt update
sudo apt install thonny -y
sudo apt install python3 -y
sudo apt install python3-pip -y
pip3 install RPi.GPIO

2) in the vs code download the remote ssh and connect with the pi through this ssh housys@192.168.2.155 then run this nano code.py so this will create a file and paste the code
3) run the code. when you run it then it will give the error because of uart setup. because in this bluetooth and uart share the same pin so we will disable the bluetooth
4) dtoverlay=disable-bt
   enable_uart=1

5) sudo systemctl disable bluetooth.service
sudo systemctl disable hciuart.service
sudo systemctl stop bluetooth.service
sudo systemctl stop hciuart.service

6) sudo nano /boot/firmware/config.txt
dtparam=spi=on
dtoverlay=enc28j60,spi0-0

b)  write ip link  this command and check whether the eth0 exist or not
c) sudo nano /etc/systemd/network/10-eth0.network open a editor then add this line
[Match]
Name=eth0

[Network]
Address=192.168.2.151/24
Gateway=192.168.2.1
DNS=8.8.8.8
DHCP=no
LinkLocalAddressing=no

[Link]
RequiredForOnline=no

d)
sudo systemctl disable dhcpcd
sudo systemctl stop dhcpcd
sudo systemctl restart systemd-networkd
and check the ip by writing this command networkctl status eth0

e)
Enable and restart
Enable and restart systemd-networkd
sudo systemctl enable systemd-networkd
sudo systemctl restart systemd-networkd

d) sudo systemctl restart systemd-networkd
   now check by writing this command. it will display the eth ip : ip addr show eth0

e) check whether the enc28j60 eth0 is connected or not
housys@raspberrypi:~ $ dmesg | grep enc28
[    3.051022] enc28j60 spi0.0: Ethernet driver 1.02 loaded
[    3.053255] enc28j60 spi0.0: chip not found
[    3.053296] enc28j60 spi0.0: probe with driver enc28j60 failed with error -5
housys@raspberrypi:~ $ 

6) how to run the program in startup by making the system d

1. Make sure your script starts like this:
in the code.py write this line at the top of the code    #!/usr/bin/env python3
2) And make it executable by writing this command in the cmd : chmod +x /home/housys/code.py
3) run this command sudo nano /etc/systemd/system/mystartup.service so one file will be open and write the below details
[Unit]
Description=Run custom Python script at boot
After=network.target

[Service]
ExecStart=/usr/bin/python3 /home/housys/code.py
WorkingDirectory=/home/housys
StandardOutput=append:/home/housys/startup.log
StandardError=append:/home/housys/startup.log
Restart=on-failure
User=housys

[Install]
WantedBy=multi-user.target

4) sudo systemctl daemon-reexec
sudo systemctl daemon-reload
sudo systemctl enable mystartup.service

5) sudo reboot


second method- this is the easiest second method i have searched and it is working
Step 1: Enable SPI and ENC28J60 overlay
sudo nano /boot/firmware/config.txt
add these lines in the file
dtparam=spi=on
dtoverlay=enc28j60

Step 2: Verify ENC28J60 is detected
dmesg | grep enc28j60

Step 3: Set Static IP on ENC28J60 (eth0)
sudo nmcli con modify "Wired connection 1" ipv4.method manual
sudo nmcli con modify "Wired connection 1" ipv4.addresses 192.168.2.155/24
sudo nmcli con modify "Wired connection 1" ipv4.gateway 192.168.2.1
sudo nmcli con modify "Wired connection 1" ipv4.dns "8.8.8.8"

step-4 for build the connection down and up
sudo nmcli con down "Wired connection 1"
sudo nmcli con up "Wired connection 1"

Step 5: Verify the Static IP
ip addr show eth0

Step 6: (Recommended) Disable Wi-Fi Completely. go to this file
sudo nano /boot/firmware/config.txt
add this line in the file below the dt-overlay=enc28j60 
dtoverlay=disable-wifi

step-7:
sudo reboot

now we have also find the issue for copying the files from the local system to the pi
âœ… Method 1 (BEST): Upload file from Windows to Pi using SCP

This avoids copy-paste completely.

Step 1: Save your file locally

On your Windows PC:

Open Notepad / VS Code

Paste your Python code

Save as:

code.py

Step 2: Upload to Raspberry Pi

Open Command Prompt / PowerShell on Windows:

scp code.py housys@192.168.2.41:/home/housys/

(Enter your Pi password when asked)

Step 3: Verify on Pi
ls -l ~/code.py
nano ~/code.py


Note- working code for the bookworm os
#!/usr/bin/env python3
import socket
import time
import serial
import threading
import queue
import lgpio
import sys

# ---------------- Utility ----------------

def get_ip_address():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.settimeout(0.1)
        s.connect(('8.8.8.8', 80))
        ip_address = s.getsockname()[0]
        s.close()
        return ip_address
    except Exception:
        return None


def remove_duplicate_substring(input_value):
    input_string = str(input_value)
    length = len(input_string)
    for i in range(1, length // 2 + 1):
        substr = input_string[:i]
        if substr * (length // i) == input_string:
            return substr
    return input_string


# ---------------- GPIO (PURE lgpio) ----------------

ENTRY_RELAY_PIN = 17  # BCM pin

gpio_handle = None

def init_gpio():
    global gpio_handle
    try:
        gpio_handle = lgpio.gpiochip_open(0)
        lgpio.gpio_claim_output(gpio_handle, ENTRY_RELAY_PIN, 1)  # relay OFF (HIGH)
        print("GPIO initialized (lgpio)")
    except Exception as e:
        print("GPIO init failed:", e)
        sys.exit(1)


def cleanup_gpio():
    global gpio_handle
    try:
        if gpio_handle is not None:
            lgpio.gpio_write(gpio_handle, ENTRY_RELAY_PIN, 1)
            lgpio.gpiochip_close(gpio_handle)
            gpio_handle = None
            print("GPIO cleaned up")
    except Exception:
        pass


# ---------------- Serial ----------------

try:
    ENTRY = serial.Serial('/dev/ttyAMA0', baudrate=115200, timeout=1)
    print("Serial opened on /dev/ttyAMA0")
except Exception as e:
    print("Serial open failed:", e)
    sys.exit(1)

prev_scanned_data_entry = {"Scanner 1": ""}


# ---------------- Queues ----------------

gpio_queue = queue.Queue()


# ---------------- GPIO Worker Thread ----------------

def perform_gpio_operations():
    while True:
        operation = gpio_queue.get()
        if operation is None:
            break

        if operation == "OPENEN":
            try:
                lgpio.gpio_write(gpio_handle, ENTRY_RELAY_PIN, 0)  # relay ON
                time.sleep(0.5)
                lgpio.gpio_write(gpio_handle, ENTRY_RELAY_PIN, 1)  # relay OFF
            except Exception as e:
                print("GPIO write error:", e)


# ---------------- QR Reader Thread ----------------

def read_qr_code(scanner, scanner_name, conn_callback):
    global prev_scanned_data_entry

    while True:
        try:
            data = scanner.readline().decode('utf-8', errors='ignore').strip()
            if data:
                if data != prev_scanned_data_entry[scanner_name]:

                    cleaned_data = data.replace("TG", "").replace("QR", "").replace("END", "")

                    if cleaned_data.isnumeric():
                        protocol = "|ENCD-" if scanner_name == "Scanner 1" else "|EXCD-"
                    else:
                        protocol = "|ENQR-" if scanner_name == "Scanner 1" else "|EXQR-"

                    cleaned_data = protocol + remove_duplicate_substring(cleaned_data) + "%\n"

                    print(f"Scanned by {scanner_name}: {cleaned_data.strip()}")

                    conn = conn_callback()
                    if conn:
                        try:
                            conn.send(cleaned_data.encode('utf-8'))
                        except Exception:
                            pass

                    prev_scanned_data_entry[scanner_name] = cleaned_data

        except Exception:
            time.sleep(0.1)


# ---------------- Heartbeat Thread ----------------

def send_heartbeat(conn_callback):
    while True:
        time.sleep(3)
        try:
            conn = conn_callback()
            if conn:
                conn.send(b'|HLT%\n')
        except Exception:
            pass


# ---------------- TCP Server ----------------

def start_server():
    HOST = get_ip_address()
    PORT = 6000

    if not HOST:
        print("No IP found, retrying in 5s...")
        time.sleep(5)
        return

    print(f"Starting server on {HOST}:{PORT}")

    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    try:
        server_socket.bind((HOST, PORT))
        server_socket.listen(1)
        print("Waiting for connection...")
        conn, addr = server_socket.accept()
        print("Connected by", addr)
    except OSError as e:
        print("Socket bind/accept failed:", e)
        server_socket.close()
        time.sleep(3)
        return

    current_conn = [conn]

    def get_conn():
        return current_conn[0]

    threading.Thread(target=send_heartbeat, args=(get_conn,), daemon=True).start()
    threading.Thread(target=read_qr_code, args=(ENTRY, "Scanner 1", get_conn), daemon=True).start()

    try:
        while True:
            try:
                data = conn.recv(1024).decode('utf-8', errors='ignore')
                if not data:
                    print("Connection lost")
                    break

                print("Received:", data.strip())

                response = ""

                if "|" in data and "%" in data:
                    start_index = data.find("|") + 1
                    end_index = data.find("%")

                    if start_index != -1 and end_index != -1:
                        extracted_data = data[start_index:end_index]

                        if extracted_data == "OPENEN":
                            gpio_queue.put("OPENEN")
                            response = "|OK%"

                        elif extracted_data.startswith("ENQR-"):
                            qr_code = extracted_data[len("ENQR-"):].strip()
                            response = "|OPENEN%" if qr_code.isalnum() else "|INVALIDEN%"

                        elif extracted_data.startswith("ENCD-"):
                            card_data = extracted_data[len("ENCD-"):].strip()
                            response = "|OPENEN%" if card_data.isnumeric() else "|INVALIDEN%"

                if response:
                    print("Sending:", response)
                    conn.send(response.encode('utf-8'))

            except Exception as e:
                print("Data handling error:", e)
                break

    finally:
        try:
            current_conn[0] = None
            conn.close()
            server_socket.close()
            print("Sockets closed, ready to reconnect")
        except Exception:
            pass


# ---------------- Main ----------------

init_gpio()

threading.Thread(target=perform_gpio_operations, daemon=True).start()

try:
    while True:
        try:
            start_server()
        except Exception as e:
            print("Unexpected error:", e)

        print("Reconnecting in 2s...")
        time.sleep(2)

finally:
    cleanup_gpio()



